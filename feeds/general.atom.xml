<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>pataliebre.net</title><link href="http://www.pataliebre.net/" rel="alternate"></link><link href="http://www.pataliebre.net/feeds/general.atom.xml" rel="self"></link><id>http://www.pataliebre.net/</id><updated>2014-06-27T00:00:00+02:00</updated><entry><title>Monitorizar una red privada desde un Nagios público con NRPE</title><link href="http://www.pataliebre.net/monitorizar-una-red-privada-desde-un-nagios-publico-con-nrpe.html" rel="alternate"></link><updated>2014-06-27T00:00:00+02:00</updated><author><name>David Castellanos</name></author><id>tag:www.pataliebre.net,2014-06-27:monitorizar-una-red-privada-desde-un-nagios-publico-con-nrpe.html</id><summary type="html">&lt;p&gt;Hace apenas un par de semanas he cambiado de trabajo, y uno de los primeros problemas que he tenido que resolver estaba relacionado con &lt;a href="http://www.nagios.org/"&gt;Nagios&lt;/a&gt;. Ocurre que tenemos unas máquinas en una red privada, y un servidor Nagios corporativo que no puede acceder a ellas.&lt;/p&gt;
&lt;p&gt;Nagios es una herramienta de monitorización de redes y sistemas de código abierto. Es extremadamente popular, y desde su origen en 1999 se usa en multitud de sistemas. Por lo general se compone de un servidor que realiza tests y recopila sus resultados, &lt;a href="http://exchange.nagios.org/directory/Addons/Monitoring-Agents"&gt;agentes&lt;/a&gt; que tienen la capacidad de realizar tests, y de &lt;em&gt;plugins&lt;/em&gt;. Estos plugins son pequeños programas que se pueden utilizar para ejecutar pruebas locales, pruebas remotas, o para realizar tareas auxiliares que asistan a los dos usos anteriores.&lt;/p&gt;
&lt;p&gt;La principal característica de Nagios es la cantidad de recursos y plugins existenes. Algunos ejemplos de repositorios de plugins son &lt;a href="http://exchange.nagios.org"&gt;Nagios Exchange&lt;/a&gt;, &lt;a href="http://nagios-plugins.org/"&gt;Nagios Plugins&lt;/a&gt;, &lt;a href="https://www.monitoring-plugins.org/"&gt;The Monitoring Plugins Project&lt;/a&gt;, etc. El blog de &lt;a href="http://www.eldespistado.com/"&gt;El Despistado&lt;/a&gt; trata casi en exclusiva sobre Nagios y tiene publicados multitud de artículos de interés.&lt;/p&gt;
&lt;p&gt;En esta entrada voy a repasar la solución que hemos adoptado. El sistema operativo de los equipos que he utilizado es Ubuntu 12.04, aunque posiblemente la configuración del entorno sea exactamente la misma (o al menos muy parecida) en Ubuntu 14.04.&lt;/p&gt;
&lt;h3&gt;Problemática&lt;/h3&gt;
&lt;p&gt;El servidor Nagios (en adelante Nagios a secas) no es capaz de llegar a un conjunto de hosts que se encuentran en una red privada. Después de investigar, encontramos dos posibles soluciones:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Realizar chequeos pasivos utilizando &lt;a href="http://exchange.nagios.org/directory/Addons/Passive-Checks/NSCA--2D-Nagios-Service-Check-Acceptor/details"&gt;NSCA&lt;/a&gt; (&lt;em&gt;Nagios Service Check Acceptor&lt;/em&gt;). La iniciativa de la comunicación la toman los hosts, y estos si que pueden llegar al Nagios porque salen a través de un NAT. Esta aproximación requiere la instalación de un servidor NSCA en el Nagios, y de un cliente NSCA en cada uno de los hosts.&lt;/li&gt;
&lt;li&gt;Utilizar &lt;a href="http://exchange.nagios.org/directory/Addons/Monitoring-Agents/NRPE--2D-Nagios-Remote-Plugin-Executor/details"&gt;NRPE&lt;/a&gt; (&lt;em&gt;Nagios Remote Plugin Executor&lt;/em&gt;) para montar un escenario muy parecido al descrito en &lt;a href="http://nagios.sourceforge.net/docs/3_0/indirectchecks.html"&gt;Multiple Indirected Service Checks&lt;/a&gt;. NRPE es un agente de Nagios que permite la monitorización mediante plugins que se encuentran instalados en los sistemas remotos. Se compone de un plugin NRPE que se debe instalar en el Nagios, y de un servidor NRPE en cada uno de los hosts.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como resulta que el Nagios es corporativo, y que ya tenían el plugin NRPE instalado, se eligió esta última opción.&lt;/p&gt;
&lt;h3&gt;Descripción del escenario&lt;/h3&gt;
&lt;p&gt;Nuestro escenario consiste básicamente en que hay un host que está detrás del firewall y que tiene acceso al resto de elementos que queremos monitorizar. El servidor Nagios se conecta a él, y éste a su vez se conectará al resto de elementos de la red:&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/indirectsvccheck2.png"&gt;&lt;img width="75%" src="/images/indirectsvccheck2.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tendremos por tanto los siguientes elementos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Un &lt;em&gt;servidor&lt;/em&gt; en el que estará instalado Nagios, y el plugin de NRPE.&lt;/li&gt;
&lt;li&gt;Una &lt;em&gt;máquina de salto&lt;/em&gt; en la que estarán instalados el servidor NRPE, el plugin NRPE, y posiblemente otros plugins de Nagios.&lt;/li&gt;
&lt;li&gt;Un conjunto de &lt;em&gt;hosts&lt;/em&gt; a monitorizar, en los que se instalarán un servidor NRPE en cada uno de ellos, y un cojunto de plugins de Nagios.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Configuración de los hosts&lt;/h4&gt;
&lt;p&gt;En los hosts es necesario instalar el servidor NRPE:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install nagios-nrpe-server nagios-plugins
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Los comandos que van a ser invocados por el servidor NRPE se configuran en el archivo &lt;code&gt;/etc/nagios/nrpe.cfg&lt;/code&gt;, como por ejemplo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;command[check_users]=/usr/lib/nagios/plugins/check_users -w 5 -c 10
command[check_load]=/usr/lib/nagios/plugins/check_load -w 15,10,5 -c 30,25,20
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como medida de seguridad, se puede añadir la IP de la máquina de salto en la variable &lt;code&gt;allowed_hosts&lt;/code&gt; del archivo &lt;code&gt;/etc/nagios/nrpe.cfg&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;allowed_hosts=192.168.60.10
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La documentación de NRPE informa que esta opción se ignora si NPRE se ejecuta bajo &lt;code&gt;inetd&lt;/code&gt; o &lt;code&gt;xinetd&lt;/code&gt;, y que en los casos que se aplica las comprobaciones que realiza son bastante rudimentarias. Por estas razones es bastante común combinar esta variable con comprobaciones adicionales en los archivos &lt;code&gt;/etc/hosts.allow&lt;/code&gt; y &lt;code&gt;/etc/hosts.deny&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;No hay que olvidar reiniciar el servicio &lt;code&gt;nagios-nrpe-server&lt;/code&gt; después de modificar la configuración:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo service nagios-nrpe-server restart
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Configuración de la máquina de salto&lt;/h4&gt;
&lt;p&gt;En la máquina de salto se deben instalar el servidor NRPE y el plugin NRPE de Nagios:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install nagios-nrpe-server nagios-plugins
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hay que prestar atención a la hora de instalar el paquete &lt;code&gt;nagios-nrpe-plugin&lt;/code&gt; porque "recomienda" el paquete &lt;code&gt;nagios3&lt;/code&gt;, y en Ubuntu los paquetes recomendados se instalan automáticamente. Como no necesitamos instalar Nagios en la máquina de salto, le debemos pasar el flag &lt;code&gt;--no-install-recommends&lt;/code&gt; a &lt;code&gt;apt-get&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install --no-install-recommends nagios-nrpe-plugin
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El paquete &lt;code&gt;nagios-nrpe-plugin&lt;/code&gt; proporciona el binario &lt;code&gt;check_nrpe&lt;/code&gt; en la ruta &lt;code&gt;/usr/lib/nagios/plugins&lt;/code&gt;. Este binario es en realidad un cliente que utilizaremos para ordenar la ejecución de tests en un host remoto que tenga instalado un servidor NRPE.&lt;/p&gt;
&lt;p&gt;Es recomendable ejecutar primero el binario &lt;code&gt;check_nrpe&lt;/code&gt; para depurar la configuración, y comprobar que la comunicación entre los hosts es correcta:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/usr/lib/nagios/plugins/check_nrpe -H 192.168.60.11 -c check_users
USERS OK - 1 users currently logged in |users=1;5;10;0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Una vez se ha comprobado que la comunicación entre la máquina de salto y los hosts es correcta, se añadirá un nuevo test &lt;em&gt;dummy&lt;/em&gt; llamado &lt;code&gt;check_remote_check&lt;/code&gt; en el servidor NRPE de la máquina de salto. La misión de este test es ordenar la ejecución de un test en un host remoto y recoger el resultado. Este nuevo test se definirá al igual que antes en el archivo  &lt;code&gt;/etc/nagios/nrpe.cfg&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;command[check_remote_check]=/usr/lib/nagios/plugins/check_nrpe -H $ARG1$ -c $ARG2$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Este test toma dos parámetros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ARG1$&lt;/code&gt; es el host remoto.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ARG2$&lt;/code&gt; es el test que se desea ejecutar.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En Ubuntu, el servidor NRPE no permite por defecto el paso de parámetros a los tests porque es un riesgo de seguridad. Para habilitar esta funcionalidad se debe modificar el fichero &lt;code&gt;/etc/nagios/nrpe.cfg&lt;/code&gt; y habilitar la opción &lt;code&gt;dont_blame_nrpe&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;dont_blame_nrpe=1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Una alternativa a habilitar los parámetros sería que en lugar de crear un comando genérico como &lt;code&gt;check_remote_check&lt;/code&gt;, añadir comandos específicos para cada host como:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;command[check_remote_users_host1]=/usr/lib/nagios/plugins/check_nrpe -H 192.168.60.11 -c check_users
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Aunque posiblemente más segura, esta aproximación tiene la desventaja de que habría que crear un comando para cada uno de los tests de cada uno de los hosts que se quisieran monitorizar.&lt;/p&gt;
&lt;p&gt;Al igual que en el caso anterior, es aconsejable configurar la variable &lt;code&gt;allowed_hosts&lt;/code&gt; para que sólo figure la IP del servidor Nagios. &lt;/p&gt;
&lt;p&gt;No hay que olvidar reiniciar el servicio &lt;code&gt;nagios-nrpe-server&lt;/code&gt; después de modificar la configuración:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo service nagios-nrpe-server restart
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Configuración servidor Nagios&lt;/h4&gt;
&lt;p&gt;Además de Nagios, en el servidor se debe instalar el plugin NRPE:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install nagios-nrpe-plugin
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si la configuración de la máquina de salto y de los hosts es correcta, el binario &lt;code&gt;check_nrpe&lt;/code&gt; debería poder ejecutar el test &lt;code&gt;check_remote_check&lt;/code&gt; en la máquina de salto:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/usr/lib/nagios/plugins/check_nrpe -H 192.168.50.5 -c check_remote_check -a 192.168.60.11 check_users
USERS OK - 1 users currently logged in |users=1;5;10;0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Por ejemplo, se pueden definir un conjunto de test que usen &lt;code&gt;check_remote_check&lt;/code&gt; de la máquina de salto de la siguiente manera:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;define host {
    use                 generic-host
    host_name           jumpbox
    alias               JumpBox
    address             192.168.50.5
}

define service {
    use                 generic-service
    host_name           jumpbox
    service_description JumpBox_PING
    check_command       check_ping!100.0,20%!500.0,60%
}

define service {
    use                 generic-service
    host_name           jumpbox
    service_description host1_System_Load_With_Params
    check_command       check_nrpe_3args!check_remote_check!192.168.60.11!check_load
}

define service {
    use                 generic-service
    host_name           jumpbox
    service_description host1_System_Load_Without_Params
    check_command       check_nrpe_1arg!check_remote_load_host1
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hay que prestar atención a los siguientes detalles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sólo se define el como &lt;em&gt;host&lt;/em&gt; la máquina de salto. No es necesario definir el resto de hosts porque no son accesibles desde Nagios, y sus tests se van a realizar indirectamente a través de la máquina de salto.&lt;/li&gt;
&lt;li&gt;El test &lt;em&gt;host1_System_Load_With_Params&lt;/em&gt; utiliza el comando &lt;code&gt;check_remote_check&lt;/code&gt; que hemos definido anteriormente en la máquina de salto.&lt;/li&gt;
&lt;li&gt;El test &lt;em&gt;host1_System_Load_Without_Params&lt;/em&gt; utiliza el comando &lt;code&gt;check_remote_load_host1&lt;/code&gt; para ejecutar un test sin que haya un paso de parámetros del Nagios a la máquina de salto.&lt;/li&gt;
&lt;li&gt;Se utilizan los comandos &lt;code&gt;check_nrpe_1arg&lt;/code&gt; y &lt;code&gt;check_nrpe_3args&lt;/code&gt; que respectivan invocan a &lt;code&gt;check_nrpe&lt;/code&gt; tomando uno y tres argumentos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A diferencia de la distribución estándar de Nagios, Ubuntu (o mas bien Debian) fragmenta la definición de los comandos en múltiples ficheros que se encuentran en &lt;code&gt;/etc/nagios-plugins/config/&lt;/code&gt;. En el caso de NRPE, utiliza el archivo &lt;code&gt;check_nrpe.cfg&lt;/code&gt;. En mi caso tuve que añadir la definición del comando &lt;code&gt;check_nrpe_3args&lt;/code&gt; para invocar a &lt;code&gt;check_nrpe&lt;/code&gt; con 3 argumentos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# this command runs a program $ARG1$ with arguments $ARG2$
define command {
    command_name    check_nrpe
    command_line    /usr/lib/nagios/plugins/check_nrpe -H $HOSTADDRESS$ -c $ARG1$ -a $ARG2$
}

# this command runs a program $ARG1$ with no arguments
define command {
    command_name    check_nrpe_1arg
    command_line    /usr/lib/nagios/plugins/check_nrpe -H $HOSTADDRESS$ -c $ARG1$
}

# this command runs a program $ARG1$ with arguments $ARG2$ and $ARG3$
define command {
    command_name    check_nrpe_3args
    command_line    /usr/lib/nagios/plugins/check_nrpe -H $HOSTADDRESS$ -c $ARG1$ -a $ARG2$ $ARG3$
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No hay que olvidar reiniciar el servicio &lt;code&gt;nagios3&lt;/code&gt; después de modificar la configuración:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo service nagios3 restart
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Problemas&lt;/h4&gt;
&lt;p&gt;El principal problema de esta aproximación es que para Nagios sólo existe un único host. Las posibilidades de filtrado son mucho más limitadas, y las alertas y los informes serán cada vez más complejos conforme la lista de hosts y de servicios vaya creciendo:&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/nagios_screenshot.png"&gt;&lt;img width="75%" src="/images/nagios_screenshot.png"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Otro problema que también es grave es que la monitorización de gran parte de la infraestructura depende exclusivamente de la máquina de salto. Como esta máquina se desconecte o se caiga nos llegarán miles de alertas, aún cuando el resto de la infraestructura esté operativa.&lt;/p&gt;
&lt;h3&gt;Conclusiones&lt;/h3&gt;
&lt;p&gt;Se ha presentado una posible solución para el problema de monitorizar una red privada desde un servidor Nagios que no tiene acceso directo a los elementos de red. No es la solución óptima porque se pierden algunas funcionalidades de Nagios como filtrar por host, informes más representativos de la infraestructura, etc., pero aún así hay situaciones en las que puede ser de utilidad este recurso.&lt;/p&gt;</summary><category term="nagios"></category><category term="firewall"></category><category term="ubuntu"></category></entry><entry><title>Blog lowcost con GitHub y Pelican</title><link href="http://www.pataliebre.net/blog-lowcost-con-github-y-pelican.html" rel="alternate"></link><updated>2014-05-27T00:00:00+02:00</updated><author><name>David Castellanos</name></author><id>tag:www.pataliebre.net,2014-05-27:blog-lowcost-con-github-y-pelican.html</id><summary type="html">&lt;!--
Status: draft
--&gt;

&lt;p&gt;Gracias a &lt;a href="https://pages.github.com/"&gt;GitHub Pages&lt;/a&gt; y un generador estático de contenido como &lt;a href="http://blog.getpelican.com/"&gt;Pelican&lt;/a&gt; es muy fácil montar un blog &lt;em&gt;lowcost&lt;/em&gt;. Un humilde ejemplo es este blog, pero hasta hace poco no había conseguido una configuración que mereciera la pena compartir.&lt;/p&gt;
&lt;h3&gt;GitHub Pages&lt;/h3&gt;
&lt;p&gt;En general, el comportamiento de GitHub Pages es muy sencillo. Prácticamente consiste en crear un repositorio &lt;code&gt;git&lt;/code&gt;, realizar un commit con documentos HTML, y unos minutos después este contenido será accesible en una URL.&lt;/p&gt;
&lt;p&gt;GitHub Pages ofrece dos modalidades de servicio: páginas para desarrolladores u organizaciones, y páginas para proyectos. Dependiendo de la modalidad que estemos usando varía la forma en la que se monta el sitio:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;En la modalidad para desarrolladores u organizaciones, se debe crear un repositorio llamado &lt;em&gt;usuario&lt;/em&gt;.github.io, donde &lt;em&gt;usuario&lt;/em&gt; es el nombre del usuario o de la organización en GitHub. La página (o páginas) HTML que se deseen servir se deben añadir directamente en la rama &lt;code&gt;master&lt;/code&gt;, y no importa lo que haya en el resto de ramas. Este contenido es accesible desde la URL &lt;strong&gt;http://&lt;em&gt;usuario&lt;/em&gt;.github.io&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;En la modalidad para proyectos, no es necesario crear nuevos repositorios. En el repositorio del proyecto se debe crear una rama llamada &lt;code&gt;gh-pages&lt;/code&gt;, y añadir ahí el contenido HTML. Este contenido será accesible desde la URL &lt;strong&gt;http://&lt;em&gt;usuario&lt;/em&gt;.github.io/&lt;em&gt;repository&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Aunque puede parecer un lío la gestión de estas ramas, afortunadamente existe una herramienta llamada &lt;a href="https://github.com/davisp/ghp-import/"&gt;ghp-import&lt;/a&gt; que facilita en gran manera estas operaciones.&lt;/p&gt;
&lt;h3&gt;Pelican&lt;/h3&gt;
&lt;p&gt;Pelican es un generador estático de contenido, al estilo de &lt;a href="http://jekyllrb.com/"&gt;Jekyll&lt;/a&gt;. Por si fuera necesario, en &lt;a href="http://staticsitegenerators.net/"&gt;Static Site Generators&lt;/a&gt; hay una recopilación de proyectos similares.&lt;/p&gt;
&lt;p&gt;Además de la &lt;a href="http://docs.getpelican.com"&gt;documentación&lt;/a&gt; del proyecto, hay multitud de páginas con instrucciones para configurar Pelican (por ejemplo &lt;a href="http://www.circuidipity.com/github-pages.html"&gt;aquí&lt;/a&gt; y &lt;a href="http://mathamy.com/migrating-to-github-pages-using-pelican.html"&gt;aquí&lt;/a&gt;). Además el comando &lt;code&gt;pelican-quickstart&lt;/code&gt; es de ayuda para crear rápidamente una configuración básica de un blog.&lt;/p&gt;
&lt;h3&gt;Usar Pelican en GitHub Pages para desarrolladores&lt;/h3&gt;
&lt;p&gt;En mi caso, elegí utilizar GitHub Pages en su modalidad para desarrolladores. Para ello, hice lo siguiente:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crear un repositorio llamado &lt;a href="https://github.com/davidcaste/davidcaste.github.io"&gt;davidcaste.github.io&lt;/a&gt;, y clonarlo en mi ordenador:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/davidcaste/davidcaste.github.io&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el repositorio local, crear una rama llamada &lt;code&gt;source&lt;/code&gt;, y cambiar a ella:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout -b source&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crear una configuración básica con &lt;code&gt;pelican-quickstart&lt;/code&gt; y seguir las instrucciones.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Llegados a este punto, contamos con una configuración Pelican funcional. La &lt;a href="http://docs.getpelican.com/en/3.3.0/getting_started.html#basic-usage"&gt;documentación de Pelican&lt;/a&gt; nos explica (entre otras muchas cosas) cómo crear contenidos y generar el contenido estático a partir de ellos.&lt;/p&gt;
&lt;p&gt;Según la configuración por defecto, las páginas generadas se almacenarán en el directorio &lt;code&gt;output&lt;/code&gt;. Este directorio &lt;strong&gt;no&lt;/strong&gt; es necesario añadirlo al repositorio, y lo ideal es añadir las siguientes líneas al fichero &lt;code&gt;.gitignore&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;output&lt;/span&gt;
&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;
&lt;span class="n"&gt;srv&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como se comentó anteriormente, GitHub Pages para desarrolladores va a servir el contenido HTML que se encuentre en la rama &lt;code&gt;master&lt;/code&gt; del repositorio. Podríamos copiar el contenido del directorio &lt;code&gt;ouput&lt;/code&gt; a algún sitio, cambiar a la rama &lt;code&gt;master&lt;/code&gt; y añadir el contenido anteriores. Es factible, pero sin duda que es un procedimiento muy tedioso.&lt;/p&gt;
&lt;p&gt;El script &lt;code&gt;ghp-import&lt;/code&gt; nos permite evitar los pasos anteriores. Con ejecutar &lt;code&gt;ghp-import -b master output&lt;/code&gt; él sólo va a realizar un commit en &lt;code&gt;master&lt;/code&gt; con los contenidos del directorio &lt;code&gt;output&lt;/code&gt;. Sólo nos quedaría subir los cambios de vuelta a GitHub con el comando &lt;code&gt;git push origin master&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;El proceso se puede automatizar aún más modificando el fichero &lt;code&gt;Makefile&lt;/code&gt; que genera &lt;code&gt;pelican-quickstart&lt;/code&gt;; en lugar de que el objetivo &lt;code&gt;github&lt;/code&gt; invoque a &lt;code&gt;ghp-import&lt;/code&gt; sobre la rama &lt;code&gt;gh-pages&lt;/code&gt;, nos interesa que se invoque sobre la rama &lt;code&gt;master&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;publish&lt;/span&gt;
    &lt;span class="n"&gt;ghp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt; &lt;span class="n"&gt;$&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OUTPUTDIR&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Conclusiones&lt;/h3&gt;
&lt;p&gt;La tupla GitHub Pages y un generador estático de contenido como Pelican permiten crear fácilmente páginas y blogs que requieren un esfuerzo de mantenimiento cercano a cero. Pelican en particular ofrece una serie de scripts y facilidades que automatizan las operaciones más tediosas.&lt;/p&gt;
&lt;p&gt;En definitiva, la posibilidad de poder usar las mismas herramientas que las usadas durante el desarrollo de software, hacen de GitHub Pages junto con Pelican ofrece una alternativa muy a tener en cuenta con respecto a otras plataformas de blogs tradicionales como &lt;a href="http://es.wordpress.com/"&gt;WordPress&lt;/a&gt; o &lt;a href="https://www.blogger.com"&gt;Blogger&lt;/a&gt;.&lt;/p&gt;</summary><category term="github"></category><category term="python"></category><category term="pelican"></category></entry><entry><title>Oracle JDK y Google Chrome en Ubuntu 12.04 LTS</title><link href="http://www.pataliebre.net/oracle-jdk-y-google-chrome-en-ubuntu-1204-lts.html" rel="alternate"></link><updated>2012-04-30T00:00:00+02:00</updated><author><name>David Castellanos</name></author><id>tag:www.pataliebre.net,2012-04-30:oracle-jdk-y-google-chrome-en-ubuntu-1204-lts.html</id><summary type="html">&lt;p&gt;A menudo utilizo &lt;em&gt;Juniper Network Connect&lt;/em&gt; para conectar a la intranet
corporativa del trabajo. Es un applet de Java que, al menos en mi caso, no
funciona bien con &lt;a href="http://openjdk.java.net"&gt;OpenJDK&lt;/a&gt; y sólo funciona con &lt;a href="http://www.java.com"&gt;Oracle JVM&lt;/a&gt; (la
anteriormente conocida como Sun JVM). En agosto del 2011, &lt;a href="https://lists.ubuntu.com/archives/ubuntu-security-announce/2011-December/001528.html"&gt;Canonical dejó de
tener permiso para distribuir la JVM de Sun&lt;/a&gt;. Aunque existen algunos PPAs
mantenidos por miembros de la comunidad de Ubuntu que ofrecen paquetes DEB del
Oracle JVM, suelen ser versiones demasiado antiguas y con problemas de
seguridad.&lt;/p&gt;
&lt;p&gt;Aunque hay disponible un instalador oficial en la &lt;a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html"&gt;sección de descargas de
Oracle para Java&lt;/a&gt;, suele ser mejor opción utilizar el script &lt;code&gt;make-jpkg&lt;/code&gt;
para crear un paquete Debian. Este script está empaquetado para Debian en el
paquete &lt;a href="http://packages.debian.org/java-package"&gt;java-package&lt;/a&gt;, y recientemente ha sido actualizado a la versión
0.50 que tiene como novedad el soporte para Java 7.&lt;/p&gt;
&lt;p&gt;Sólo he encontrado un problema con estos paquetes, y es que no instalan el
plugin de Java en el navegador Google Chrome, sin embargo si lo hace para
Iceweasel y Chromium. Es problema es muy sencillo de resolver, sólo es
necesario crear un enlace simbólico al fichero &lt;code&gt;libnpjp2.so&lt;/code&gt; que se encuentra
en el JRE. Utilizando el &lt;a href="http://www.debian-administration.org/articles/91"&gt;sistema de alternatives de Debian&lt;/a&gt; se haría de la
siguiente manera:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ sudo update-alternatives --install \
&amp;gt; /usr/lib/mozilla/plugins/libjavaplugin.so \
&amp;gt; mozilla-javaplugin.so \
&amp;gt; /usr/lib/jvm/j2sdk1.6-oracle/jre/lib/i386/libnpjp2.so 100
&lt;/pre&gt;&lt;/div&gt;</summary><category term="java"></category><category term="ubuntu"></category><category term="alternatives"></category></entry><entry><title>hello world!</title><link href="http://www.pataliebre.net/hello-world.html" rel="alternate"></link><updated>2012-04-22T00:00:00+02:00</updated><author><name>David Castellanos</name></author><id>tag:www.pataliebre.net,2012-04-22:hello-world.html</id><summary type="html">&lt;p&gt;Quizá sea por deformación profesional, vaguería, o una falta (puntual) de
imaginación, no se me ocurre una mejor forma de comenzar este lío que con un
estupendo &lt;em&gt;Hello World!&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El objetivo de este blog es muy humilde: continuamente estoy aprendiendo cosas,
y continuamente estoy olvidando cosas. Y como soy vago, me fastidia sobremanera
tener que volver a aprenderlas. Normalmente cuando me quejo de todo esto me
suelen regañar con un  "deberías haberlo apuntado en algún sitio".&lt;/p&gt;
&lt;p&gt;Así que ya
tengo la motivación que necesitaba: voy a escribir sobre cosas de mi trabajo
que &lt;em&gt;sé&lt;/em&gt; que voy a olvidar y que muy posiblemente vaya a necesitar en un
futuro. Y si de paso resulta que es útil a alguien, perfecto. Imagino que la
mayoría de las entradas de este blog serán sobre computación y
programación en general, y sobre Python en particular. Entre mis intereses se
encuentran temas como el toolkit GTK, Eclipse (tanto el IDE como la
plataforma), Java, Android, Git, etc.&lt;/p&gt;</summary><category term="me"></category></entry></feed>